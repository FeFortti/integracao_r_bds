<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>BDs Relacionais &amp; Programação Estatística</title>
    <meta charset="utf-8" />
    <meta name="author" content=" Caio Lente   Fernanda Fortti" />
    <link href="apresentacao_files/remark-css/default.css" rel="stylesheet" />
    <link href="apresentacao_files/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# BDs Relacionais &amp; Programação Estatística
## <br>Disciplina MAC5861 - IME/USP<br>
### <br>Caio Lente <br> Fernanda Fortti<br>
### <br>13 de novembro de 2019<br>

---



class: inverse, center, middle
# Motivação

---
# O Problema

- [Bancos de Dados (BDs) relacionais]() são [limitados]() no que diz respeito à 
[programação estatística]()
  
  - Moda, percentil, modelagem e cálculos estatísticos são tarefas difíceis 
  para Sistemas Gerenciadores de Bancos de Dados (SGBDs).
  
    &gt;*While basic aggregation operations (SUM, AVG) are part of SQL, there is 
    no support for other commonly used operations like variance and co-variance.
    Such computations, as well as more advanced ones like regression and 
    principal component analysis, are usually performedusing statistical 
    packages and libraries.*
                                            (Srivastava &amp; Ngo, 2014)

&lt;img src="figures/logos_bds_relac.png" style="display: block; margin: auto;" /&gt;

---
# O Problema
  
- [Ferramentas estatísticas]() nem sempre são viáveis com [muitos dados]()
  
  - O que cabe em disco não necessariamente cabe na memória
  
  - Se os dados já estão em um BD, por que trazê-los para memória?
  
    &gt;*If your data fits in memory there is no advantage to putting it in a 
    database: it will only be slower and more frustrating.*
                                                    (Wickham, 2019)
                                          
&lt;img src="figures/logos_soft_estat.png" style="display: block; margin: auto;" /&gt;

---
class: inverse, center, middle
# Soluções

---
# Solução 1

[Implementação]() da ferramenta estatística dentro dos SGBDs relacionais

- [Limitações]()

  - Nem todo SGBD apresenta essa [funcionalidade]() (Postgres, p. ex.)

  - Vendedores dos SGBDs precisam implementar a funcionalidade (o que pode
  custar [caro]() e/ou [demorar]() para ser feito)

  - [Dificilmente]() a implementação será [*open source*]()

```sql
-- calculate simple quantiles
EXEC sp_execute_external_script
  @language = N'R'
  ,@script = N'
    res &lt;- quantile(InputDataSet$Ages);
    print(res);'
  ,@input_data_1 = N'
    SELECT Ages = DATEDIFF(YEAR,[BirthDate],GETDATE())
    FROM [AdventureWorksDW2014].[dbo].[DimCustomer];';
```


---
# Solução 2

[Conexão]() do software estatístico aos SGBDs relacionais

- Por que usar o [R]() como principal linguagem estatística?

   - Linguagem estatística mais amplamente adotada
   
   - *Open source*
   
   - Comunidade ativa
   
&lt;img src="figures/logo_r2.png" style="display: block; margin: auto 0 auto auto;" /&gt;


```r
con_postgres &lt;- RPostgres::dbConnect(
  RPostgres::Postgres(),
  dbname = "my_database",
  host = "localhost", port = 54320,
  user = "postgres", pwd
)
```

---
class: inverse, center, middle
# Dbplyr

---
# Diagrama

![](figures/diagrama.png)&lt;!-- --&gt;

---
# BDs

[Qualquer SGBD]() pode ser suportado [desde que um *backend* seja criado]()

  - Aproveita-se do fato de que todo SGBD tem suporte para conexões externas



&lt;img src="figures/logos_bds_relac2.png" style="display: block; margin: auto;" /&gt;


---
# DBI

[Interface de banco de dados]() para comunicação entre R e SGDBs
  
  - Permite que o R envie comandos para os bancos de dados, 
  [independentemente do SGBD utilizado]()
  
  - [Padronização das funções]() possibilita a construção de pacotes genéricos
  para lidar com os dados de uma conexão, facilitando:
    - A criação e implementação dos pacotes (necessidade de menos decisões
    arbitrárias) 
    - A manipulação dos usuários (padrão familiar)
  
  - Fornece uma [especificação de interface]() que permite qualquer um criar
  novos *backends* para um BD
  
---
# Backends dos SGBDs relacionais

[Bibliotecas específicas]() que permitem a conexão entre o R e SGBDs relacionais
  
  - Permite o envio de *queries* e recebimento de dados do BD
  
  - Permite ao [`dplyr`]() trabalhar com [múltiplas fontes de dados dados]()
  usando o [mesmo código]()
    
  - Funções de leitura (`dbReadTable`) e escrita (`dbWriteTable`) de tabelas
  através de uma conexão
  
  - Exemplos:
    - [`RMariaDB`]() 
    - [`RPostgres`]()  
    - [`RSQLite`]()
    - [`bigrquery`]()
    
---
# BD, DBI, Backends dos SGBDs relacionais

Os argumentos para [`DBI :: dbConnect ()`]() variam de banco de dados para banco
de dados, mas o primeiro argumento é sempre o *backend* do banco de dados:

  - [RSQLite :: SQLite ()]() para `RSQLite`
  - [RMySQL :: MySQL ()]() para `RMySQL`
  - [RPostgreSQL :: PostgreSQL ()]() para `RPostgreSQL`
  - [bigrquery :: bigquery ()]() para `BigQuery`
  - [odbc :: odbc ()]() para `odbc`

`SQLite` precisa apenas de outro argumento: o caminho para o banco de dados.
Porém, a maioria dos bancos de dados não está em um arquivo, mas sim em outro
servidor, fazendo com que, na prática, o código seja semelhante a:


```r
con &lt;- DBI::dbConnect(RMySQL::MySQL(), 
  host = "database.rstudio.com",
  user = "fernanda",
  password = rstudioapi::askForPassword("Database password")
)
```

---
# Dbplyr

Pacote do R para [tradução de código `dplyr` em código SQL]() e [tradução da]()
[resposta do banco de dados em um *R data frame*]()  

  - [De forma automática](), consegue gerar um código em SQL a partir de um
  código em R
  
  - Capaz de transformar verbos do pacote do R `dplyr` em *queries* SQL
  completas (atua, portanto, como *backend* do `dplyr`)
  
  - Permite [receber resultados parciais dos SGBDs relacionais]() e traduzí-los
  em uma resposta interpretável pelo R
  
  - Não consegue traduzir qualquer código, mas ajuda bastante


```r
dbplyr::translate_sql(x ^ 2L)
#&gt; &lt;SQL&gt; POWER(`x`, 2)

dbplyr::translate_sql(log(x, 10))
#&gt; &lt;SQL&gt; LOG(10.0, `x`)
```

---
# Dplyr

Pacote do R com gramática para [manipulação de dados]()

  - Fornece um [conjunto consistente de verbos]() que ajudam a resolver os
  desafios
  mais comuns de manipulação de dados

  - [Transformação sintática]() sobre tabelas
  
  - [*Pipelines*](), o que permite que cada linha delimite uma ação, como se
  fosse uma receita de bolo
  
  - [Operadores infixos](), o que permite que se saiba exatamente a ordem das
  operações
  
  - [Metaprogramação](), o que garante um código mais limpo
  
  - [*Quasi-quotations*](), o que garante a escrita de funções confiáveis que
  reduzem a duplicação/duplicidade no código
  
  - [Pacote do R mais famoso e mais utilizado](), graças às vantagens
  mencionadas

---
# Dplyr

Operações [*lazy*]()

  - [Ao trabalhar com bancos de dados](), o `dplyr` tenta ser o mais preguiçoso
  possível
  
  - Atrasa a execução de qualquer trabalho até o último momento possível: 
  reúne tudo o que você deseja fazer e [envia ao BD em uma única etapa]().
  
  - Nunca puxa [dados para o R](), a menos que você os [solicite]()
  [explicitamente]() (`print()`, `collect()`).

---
class: inverse, center, middle
# Exemplos

---
# Dplyr

```r
cnes %&gt;%
  select(def_atividad, def_turno_at, starts_with("mun_")) %&gt;%
  filter(def_atividad == "Unidade SEM atividade de Ensino") %&gt;%
  mutate(
    so_um_turno = ifelse(grepl("SOMENTE", def_turno_at), 1, 0),
    localizacao = ifelse(mun_CAPITAL == "S", "CAPITAL", "INTERIOR")
  ) %&gt;%
  group_by(localizacao) %&gt;%
  summarise(f_so_um_turno = sum(so_um_turno)*100/n())
  
#&gt; # A tibble: 2 x 2
#&gt;   localizacao f_so_um_turno
#&gt;   &lt;chr&gt;               &lt;dbl&gt;
#&gt; 1 CAPITAL              1.10
#&gt; 2 INTERIOR             1.80
```

---
# Dbplyr

```r
* tbl(con, "cnes") %&gt;%
  select(def_atividad, def_turno_at, starts_with("mun_")) %&gt;%
  filter(def_atividad == "Unidade SEM atividade de Ensino") %&gt;%
  mutate(
    so_um_turno = ifelse(grepl("SOMENTE", def_turno_at), 1, 0),
    localizacao = ifelse(mun_CAPITAL == "S", "CAPITAL", "INTERIOR")
  ) %&gt;%
  group_by(localizacao) %&gt;%
  summarise(f_so_um_turno = sum(so_um_turno)*100/n()) %&gt;%
* collect()

#&gt; # A tibble: 2 x 2
#&gt;   localizacao f_so_um_turno
#&gt;   &lt;chr&gt;               &lt;dbl&gt;
#&gt; 1 CAPITAL              1.10
#&gt; 2 INTERIOR             1.80
```

---
# Tradução

[`show_query()`]()

[`explain()`]()

```sql
SELECT "localizacao", SUM("so_um_turno") * 100.0 / COUNT(*) AS "f_so_um_turno"
FROM (SELECT "def_atividad", "def_turno_at", "mun_MUNNOME", "mun_MUNNOMEX", "mun_AMAZONIA", "mun_FRONTEIRA", "mun_CAPITAL", "mun_MSAUDCOD", "mun_RSAUDCOD", "mun_CSAUDCOD", "mun_LATITUDE", "mun_LONGITUDE", "mun_ALTITUDE", "mun_AREA", "mun_codigo_adotado", "mun_coordenadas", CASE WHEN ("def_turno_at" like 'SOMENTE') THEN (1.0) WHEN NOT("def_turno_at" like 'SOMENTE') THEN (0.0) END AS "so_um_turno", CASE WHEN ("mun_CAPITAL" = 'S') THEN ('CAPITAL') WHEN NOT("mun_CAPITAL" = 'S') THEN ('INTERIOR') END AS "localizacao"
FROM (SELECT *
FROM (SELECT "def_atividad", "def_turno_at", "mun_MUNNOME", "mun_MUNNOMEX", "mun_AMAZONIA", "mun_FRONTEIRA", "mun_CAPITAL", "mun_MSAUDCOD", "mun_RSAUDCOD", "mun_CSAUDCOD", "mun_LATITUDE", "mun_LONGITUDE", "mun_ALTITUDE", "mun_AREA", "mun_codigo_adotado", "mun_coordenadas"
FROM "cnes") "dbplyr_1033"
WHERE ("def_atividad" = 'Unidade SEM atividade de Ensino')) "dbplyr_1034") "dbplyr_1035"
GROUP BY "localizacao"
```

```sql
HashAggregate  (cost=4091.28..4091.33 rows=2 width=64)
  Group Key: CASE WHEN (cnes."mun_CAPITAL" = 'S'::text) THEN 'CAPITAL'::text WHEN (cnes."mun_CAPITAL" &lt;&gt; 'S'::text) THEN 'INTERIOR'::text ELSE NULL::text END
  -&gt;  Seq Scan on cnes  (cost=0.00..3810.18 rows=22488 width=77)
        Filter: (def_atividad = 'Unidade SEM atividade de Ensino'::text)
```

---

# Desempenho?


---
class: inverse, center, middle
# Obrigado(a)!
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create();
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
